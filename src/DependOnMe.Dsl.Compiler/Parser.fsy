%{
open System
open DslAst
open TextUtilities
open Errors

let errorLogger = ErrorLogger()

let reportRange ((startPos, endPos): PosRange) msg = (startPos, endPos, msg) |> ProdError |> Range |> errorLogger.Report

let reportPoint pos msg = (pos, msg) |> TermError |> Point |> errorLogger.Report

let (||||>) (x1, x2, x3, x4) f = f x1 x2 x3 x4

let (|Bf1Presense|Bf1Unique|) (boolFlag1Presence: BoolFlag1 option, lexeme) = 
    match lexeme with
        | BoolFlag1(b) when boolFlag1Presence.IsNone     -> Bf1Unique(b)
        | BoolFlag1(_) when not boolFlag1Presence.IsNone -> Bf1Presense
        | t -> failwithf "Incorrect node: %A" t

let (|Bf2Presense|Bf2Unique|) (boolFlag2Presence: BoolFlag2 option, lexeme) = 
    match lexeme with
        | BoolFlag2(b) when boolFlag2Presence.IsNone     -> Bf2Unique(b)
        | BoolFlag2(_) when not boolFlag2Presence.IsNone -> Bf2Presense
        | t -> failwithf "Incorrect node: %A" t

let testBoolFlag1 boolFlag1Presence lexeme = 
    match (boolFlag1Presence, lexeme) with
        | Bf1Presense  -> false
        | Bf1Unique(b) -> true
        
let testBoolFlag2 boolFlag2Presence lexeme = 
    match (boolFlag2Presence, lexeme) with
        | Bf2Presense  -> false
        | Bf2Unique(b) -> true

let testInnerDeclaration lexems = 
    let rec innerTest (boolFlag1Presence: BoolFlag1 option) (boolFlag2Presence: BoolFlag2 option) (registrations:  Registration list) = function
        | (BoolFlag1(v) as b)::t -> if testBoolFlag1 boolFlag1Presence b then 
                                        (Some v, boolFlag2Presence, registrations, t) ||||> innerTest 
                                    else failwith "Presense of Flag1 is detected"
        | (BoolFlag2(v) as b)::t -> if testBoolFlag2 boolFlag2Presence b then 
                                        (boolFlag1Presence, Some v, registrations, t) ||||> innerTest 
                                    else failwith "Presense of Flag2 is detected"
        | Registration(r)::t     -> (boolFlag1Presence, boolFlag2Presence, registrations @ r, t) ||||> innerTest
        | []                     -> (boolFlag1Presence, boolFlag2Presence, registrations)

    innerTest None None [] lexems
%}

%token TESTHEADER
%token ERROR
%token ARROW
%token EQ
%token BF1
%token BF2
%token TRUE
%token FALSE
%token QUOT
%token MODULE
%token DEPENDENCIES
%token <string> FQN
%token <string> SNAME
%token EOF

%start start
%type <DslAst.DependencyTest> start

%%

start:
    | testBody EOF { $1 }

testBody:
    | TESTHEADER SNAME expressionSet
        {
            let boolFlag1, boolFlag2, registrations = testInnerDeclaration $3
            Test($2, boolFlag1.Value, boolFlag2.Value, registrations, posRangeExt parseState 1 2, posRangeExt parseState 1 3)
        }

expressionSet:
    | expressionSet bodyExpression { $2::$1 |> List.rev }
    | bodyExpression { [$1] }

bodyExpression:
    | boolFlag1       { BoolFlag1($1) }
    | boolFlag2       { BoolFlag2($1) }
    | registrationSet { Registration($1 |> List.rev) }

registration:
    | FQN ARROW FQN     { Class($1, $3, posRange parseState 1, posRange parseState 3) }
    | MODULE FQN        { Module($2, posRange parseState 1, posRange parseState 2) }
	| errorRegistration { $1 }

registrationSet:
    | registration                 { [$1] }
    | registrationSet registration { $2::$1 }

boolFlag1:
    | BF1 EQ TRUE    { BoolFlag1.Flag(true,  posRangeExt parseState 1 3) }
    | BF1 EQ FALSE   { BoolFlag1.Flag(false, posRangeExt parseState 1 3) }
    | errorBoolFlag1 { $1 }

boolFlag2:
    | BF2 EQ TRUE    { BoolFlag2.Flag(true,  posRangeExt parseState 1 3) }
    | BF2 EQ FALSE   { BoolFlag2.Flag(false, posRangeExt parseState 1 3) }
    | errorBoolFlag2 { $1 }

errorBoolFlag1:
    | BF1       { 
                    (endPos parseState 1, ErrMsg.EqMissing) ||> reportPoint
                    BoolFlag1.Error(BoolFlagMissingPart.Equal, endPos parseState 1, posRangeExt parseState 1 1) 
                }
    | BF1 EQ    { 
                    (endPos parseState 2, ErrMsg.BoolMissing) ||> reportPoint
                    BoolFlag1.Error(BoolFlagMissingPart.Value, endPos parseState 2, posRangeExt parseState 1 2) 
                }
    | BF1 TRUE  { 
                    (endPos parseState 1, ErrMsg.EqMissing) ||> reportPoint
                    BoolFlag1.Error(BoolFlagMissingPart.Equal, endPos parseState 1, posRangeExt parseState 1 2) 
                }
    | BF1 FALSE { 
                    (endPos parseState 1, ErrMsg.EqMissing) ||> reportPoint
                    BoolFlag1.Error(BoolFlagMissingPart.Equal, endPos parseState 1, posRangeExt parseState 1 2) 
                }

errorBoolFlag2:
    | BF2       { 
                    (endPos parseState 1, ErrMsg.EqMissing) ||> reportPoint
                    BoolFlag2.Error(BoolFlagMissingPart.Equal, endPos parseState 1, posRangeExt parseState 1 1) 
                }
    | BF2 EQ    { 
                    (endPos parseState 2, ErrMsg.BoolMissing) ||> reportPoint
                    BoolFlag2.Error(BoolFlagMissingPart.Value, endPos parseState 1, posRangeExt parseState 1 2) 
                }
	| BF2 TRUE  { 
                    (endPos parseState 1, ErrMsg.EqMissing) ||> reportPoint
                    BoolFlag2.Error(BoolFlagMissingPart.Equal, endPos parseState 1, posRangeExt parseState 1 2) 
                }
    | BF2 FALSE { 
                    (endPos parseState 1, ErrMsg.EqMissing) ||> reportPoint
                    BoolFlag2.Error(BoolFlagMissingPart.Equal, endPos parseState 1, posRangeExt parseState 1 2) 
                }

errorRegistration:
	| FQN FQN   { 
                    (endPos parseState 1, ErrMsg.ArrowMissing) ||> reportPoint
                    ClassError(ClassRegMissingPart.Arrow,  endPos parseState 1, posRangeExt parseState 1 2) 
                }
	| FQN ARROW { 
                    (endPos parseState 2, ErrMsg.FqnMissing) ||> reportPoint
                    ClassError(ClassRegMissingPart.Name,   endPos parseState 2, posRangeExt parseState 1 2) 
                }
	| MODULE    { 
                    (endPos parseState 1, ErrMsg.FqnMissing) ||> reportPoint
                    ModuleError(ModuleRegMissingPart.Name, endPos parseState 1, posRangeExt parseState 1 1) 
                }