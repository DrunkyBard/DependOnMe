%{
open System
open DslAst
open TextUtilities
open Common
open Compilation
open System.Collections.Generic
open Errors
open Positioning
open DataStructures
open Navigation

let errorLogger = ErrorLogger()

let index = RedBlackTree<PosRange, IndexTerm>(PosRangeComparer.Instance)
let testIndex = PositionSet()

let addIdx posRange term = index.Insert(posRange, term)
let addTestIdx posRange term = testIndex.Insert(PositionIndex(posRange, term))

let separate lexems = 
    let rec separateRec (boolFlags1: BoolFlag1 list) (boolFlags2: BoolFlag2 list) (registrations:  Registration list) = function
        | (BoolFlag1(BoolFlag1.Flag(_) as b))::t -> 
            (b::boolFlags1, boolFlags2, registrations, t)  ||||> separateRec 
        | (BoolFlag2(BoolFlag2.Flag(_) as b))::t -> 
            (boolFlags1, b::boolFlags2, registrations, t)  ||||> separateRec
        | Registration(r)::t           -> 
            (boolFlags1, boolFlags2, List.append registrations r, t) ||||> separateRec
        | any::t -> (boolFlags1, boolFlags2, registrations, t) ||||> separateRec
        | []     -> (boolFlags1 |> List.rev, boolFlags2 |> List.rev, registrations)

    separateRec [] [] [] lexems
%}

%token TESTHEADER
%token ARROW
%token EQ
%token BF1
%token BF2
%token TRUE
%token FALSE
%token QUOT
%token MODULE
%token DEPENDENCIES
%token <string> FQN
%token <string> SNAME
%token EOF

%start start
%type <DslAst.DependencyTest> start

%%

start:
    | testBody EOF { $1 }
    | EOF { DependencyTest.Empty }


testHeader:
    | TESTHEADER SNAME { TestDeclaration.Full($2, posRange parseState 1, posRange parseState 2) }
    | TESTHEADER       
        { 
            (endPos parseState 1, ErrMsg.TestNameIsNotDefined, errorLogger) |||> reportPoint
            TestDeclaration.Partial(posRange parseState 1)
        }
    | any 
        { 
            let errPos, errToken = $1
            (errPos, ErrMsg.TestHeaderExpected, errorLogger) |||> reportRange
            TestDeclaration.Error(errPos)
        }

testBody:
    | testHeader expressionSet
        {
            (posRange parseState 1, $1 |> TestDeclarationTerm) ||> addIdx
            (posRange parseState 1, $1 |> TestDeclarationTerm) ||> addTestIdx
            let boolFlags1, boolFlags2, registrations = separate $2
            Test($1, boolFlags1, boolFlags2, registrations, posRangeOut parseState 1 2)
        }

expressionSet:
    | expressionSet bodyExpression  { $2::$1 |> List.rev }
    | bodyExpression  { [$1] }

bodyExpression:
    | boolFlag1       
                { 
                    (posRange parseState 1, $1 |> BoolFlag1Term) ||> addIdx
                    (posRange parseState 1, $1 |> BoolFlag1Term) ||> addTestIdx
                    BoolFlag1($1)
                }
    | boolFlag2       
                { 
                    (posRange parseState 1, $1 |> BoolFlag2Term) ||> addIdx
                    (posRange parseState 1, $1 |> BoolFlag2Term) ||> addTestIdx
                    BoolFlag2($1)
                }
    | registrationSet { Registration($1 |> List.rev) }
    | errorExprBody   { 
                          let pos  = posRange parseState 1
                          let term = pos |> ErrorTerm.Error
                          (pos, term |> IndexTerm.Error) ||> addIdx
                          (pos, term |> IndexTerm.Error) ||> addTestIdx
                          term |> Declaration.Error
                      }

registration:
    | FQN ARROW FQN     { Class($1, $3, posRange parseState 1, posRange parseState 2, posRange parseState 3) }
    | MODULE FQN        { Module($2, posRange parseState 1, posRange parseState 2) }
	| errorRegistration { $1 }

registrationSet:
    | registration {
                       (posRange parseState 1, $1 |> RegistrationTerm) ||> addIdx
                       (posRange parseState 1, $1 |> RegistrationTerm) ||> addTestIdx
                       [$1]
                   }
    | registrationSet registration 
                   { 
                       (posRange parseState 2, $2 |> RegistrationTerm) ||> addIdx
                       (posRange parseState 2, $2 |> RegistrationTerm) ||> addTestIdx
                       $2::$1 
                   }

boolValue:
    | TRUE  { true }
    | FALSE { false }

boolFlag1:
    | BF1 EQ boolValue { BoolFlag1.Flag($3,  posRange parseState 1, startPos parseState 2, posRange parseState 3) }
    | errorBoolFlag1   { $1 }

boolFlag2:
    | BF2 EQ boolValue { BoolFlag2.Flag($3,  posRange parseState 1, startPos parseState 2, posRange parseState 3) }
    | errorBoolFlag2   { $1 }

errorBoolFlag1:
    | BF1 error     { 
                        (endPos parseState 1, ErrMsg.EqMissing, errorLogger) |||> reportPoint
                        BoolFlag1.Error(BoolFlagMissingPart.EqualAfter(endPos parseState 1))
                    }
    | BF1 EQ        { 
                        (endPos parseState 2, ErrMsg.BoolMissing, errorLogger) |||> reportPoint
                        BoolFlag1.Error(BoolFlagMissingPart.Value(endPos parseState 2))
                    }
    | BF1 boolValue { 
                       (endPos parseState 1, ErrMsg.EqMissing, errorLogger) |||> reportPoint
                       BoolFlag1.Error(BoolFlagMissingPart.EqualBetween(posRangeIn parseState 1 2))
                    }
    | BF1           { 
                        (endPos parseState 1, ErrMsg.EqMissing, errorLogger) |||> reportPoint
                        BoolFlag1.Error(BoolFlagMissingPart.EqualBetween(posRangeIn parseState 1 2))
                    }
    | EQ boolValue  {
                       (startPos parseState 1, ErrMsg.BoolFlagTokenExpected, errorLogger) |||> reportPoint
                       BoolFlag1.Error(BoolFlagMissingPart.BoolFlagTerm(startPos parseState 1)) 
                    }
    | boolValue     {
                       (startPos parseState 1, ErrMsg.BoolFlagTokenExpected, errorLogger) |||> reportPoint
                       BoolFlag1.Error(BoolFlagMissingPart.BoolFlagTerm(startPos parseState 1))
                    }

errorBoolFlag2:
    | BF2 EQ        { 
                        (endPos parseState 2, ErrMsg.BoolMissing, errorLogger) |||> reportPoint
                        BoolFlag2.Error(BoolFlagMissingPart.Value(endPos parseState 1))
                    }
	| BF2 boolValue {      
                        (endPos parseState 1, ErrMsg.EqMissing, errorLogger) |||> reportPoint
                        BoolFlag2.Error(BoolFlagMissingPart.EqualBetween(posRangeIn parseState 1 2))
                    }
    | BF2           { 
                        (endPos parseState 1, ErrMsg.EqMissing, errorLogger) |||> reportPoint
                        BoolFlag2.Error(BoolFlagMissingPart.EqualBetween(posRangeIn parseState 1 2))
                    }

errorRegistration:
	| FQN FQN   { 
                    (endPos parseState 1, ErrMsg.ArrowMissing, errorLogger) |||> reportPoint
                    ClassError(ClassRegMissingPart.Arrow(posRangeIn parseState 1 2)) 
                }
	| FQN ARROW { 
                    (endPos parseState 2, ErrMsg.FqnMissing, errorLogger) |||> reportPoint
                    ClassError(ClassRegMissingPart.ImplName(endPos parseState 2))
                }
	| MODULE    { 
                    (endPos parseState 1, ErrMsg.FqnMissing, errorLogger) |||> reportPoint
                    ModuleError(ModuleRegMissingPart.Name(endPos parseState 1))
                }

errorExprBody:
    | errorExprBody SNAME {
                              let lexbuf   = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
                              let posRange = (lexbuf.StartPos, lexbuf.EndPos)
                              let errToken = new string(lexbuf.Lexeme)
                              (posRange, ErrMsg.UnexpectedToken errToken, errorLogger) |||>reportRange
                          }
    | SNAME               { 
                              let lexbuf   = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
                              let posRange = (lexbuf.StartPos, lexbuf.EndPos)
                              let errToken = new string(lexbuf.Lexeme)
                              (posRange, ErrMsg.UnexpectedToken errToken, errorLogger) |||>reportRange
                          }

recover:
    | error
        {
            let lexbuf   = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
            let posRange = (lexbuf.StartPos, lexbuf.EndPos)
            let errToken = new string(lexbuf.Lexeme)
            (posRange, ErrMsg.UnexpectedToken errToken, errorLogger) |||>reportRange
        }

any:
    | TESTHEADER   { posRangeAndToken parseState }
    | ARROW        { posRangeAndToken parseState }
    | EQ           { posRangeAndToken parseState }
    | BF1          { posRangeAndToken parseState }
    | BF2          { posRangeAndToken parseState }
    | TRUE         { posRangeAndToken parseState }
    | FALSE        { posRangeAndToken parseState }
    | QUOT         { posRangeAndToken parseState }
    | MODULE       { posRangeAndToken parseState }
    | DEPENDENCIES { posRangeAndToken parseState }
    | FQN          { posRangeAndToken parseState }
    | SNAME        { posRangeAndToken parseState }

